package ray1024.projects.collectioncontroller;

import ray1024.projects.collectioncontroller.commands.*;
import ray1024.projects.collectioncontroller.interfaces.IInputSource;
import ray1024.projects.collectioncontroller.server.Server;
import ray1024.projects.collectioncontroller.terminal.Terminal;
import ray1024.projects.collectioncontroller.tools.ConsoleSourceReader;
import ray1024.projects.collectioncontroller.tools.NonBlockingConsoleSourceReader;
import ray1024.projects.collectioncontroller.tools.ConsoleSourceWriter;
import ray1024.projects.collectioncontroller.tools.Phrases;

import java.io.IOException;

/**
 * Главный красс создающий и запускающий Терминал
 *
 * @MyTag aloha
 */
public class ServerApplication {

    static {
        AddCommand.command.getName();
        AddIfMinCommand.command.getName();
        ClearCommand.command.getName();
        ExitCommand.command.getName();
        FilterLessThanStudentsCountCommand.command.getName();
        FilterStartsWithNameCommand.command.getName();
        HelpCommand.command.getName();
        InfoCommand.command.getName();
        PrintDescendingCommand.command.getName();
        RemoveByIDCommand.command.getName();
        RemoveFirstCommand.command.getName();
        SaveCommand.command.getName();
        ShowCommand.command.getName();
        ShuffleCommand.command.getName();
        UpdateByIDCommand.command.getName();
        ExecuteScriptCommand.command.getName();
    }
    //  User class
    //  Request class(type,command,user)
    //  Response class(type,text_answer,server)
    //  ConnectionAcceptor(nonblocking) + returns new User
    //  Terminal for everyone of users
    //  UsersManager(disconnect, connect)
    //
    //


    public static void main(String[] args) {

        Server server = new Server();
        while (true) {
            try {
                server.tick();
            } catch (IOException e) {
                throw new RuntimeException(e.getMessage());
            }
        }
    }

}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.data.StudyGroup;
import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Команда добавляет в коллекцию элемент
 */
public class AddCommand extends BaseCommand {
    private final StudyGroup studyGroup = new StudyGroup();
    public static final AddCommand command = new AddCommand();

    private AddCommand() {
        setName("add").setDescription(Phrases.getPhrase("AddCommandDescription"));
        stepsCount = studyGroup.getStepsCount();
        CommandRegister.registerCommand(this);
    }


    @Override
    public void execute() throws RuntimeException {
        try {
            getParentShell().getParentTerminal().getCollectionController().getManagedCollection().getVec().add(studyGroup);
        } catch (Exception e) {
            throw new RuntimeException(Phrases.getPhrase("Can'tExecuteCommand"));
        }
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
        studyGroup.inputLine(line);
    }

    @Override
    public boolean isObjectReady() {
        return studyGroup.isObjectReady();
    }

    @Override
    public String getStepDescription() {
        return studyGroup.getStepDescription();
    }

    @Override
    public BaseCommand setArgs(String[] args) {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }

}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.data.StudyGroup;
import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Команда добавляет в коллекция элемент если он меньше всех элементов коллекции
 * Т.к сортировка по умолчанию сравнивает группы по названию, то добавляет элемент если название его группы лексикографически меньше любого другого названия групп из коллекции
 */
public class AddIfMinCommand extends BaseCommand {
    private final StudyGroup studyGroup = new StudyGroup();

    public static final AddIfMinCommand command = new AddIfMinCommand();

    private AddIfMinCommand() {
        this.setName("add_if_min").setDescription(Phrases.getPhrase("AddIfMinCommandDescription"));
        CommandRegister.registerCommand(this);
        stepsCount = studyGroup.getStepsCount();
    }


    @Override
    public void execute() throws RuntimeException {
        try {
            if (getParentShell().getParentTerminal().getCollectionController().getManagedCollection().getVec().stream().allMatch((i) -> {
                return i.compareTo(studyGroup) > 0;
            }))
                getParentShell().getParentTerminal().getCollectionController().getManagedCollection().getVec().add(studyGroup);
        } catch (Exception e) {
            throw new RuntimeException(Phrases.getPhrase("Can'tExecuteCommand"));
        }
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
        studyGroup.inputLine(line);
    }

    @Override
    public boolean isObjectReady() {
        return studyGroup.isObjectReady();
    }

    @Override
    public String getStepDescription() {
        return studyGroup.getStepDescription();
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.interfaces.IExecute;
import ray1024.projects.collectioncontroller.terminal.MicroShell;
import ray1024.projects.collectioncontroller.terminal.Terminal;
import ray1024.projects.collectioncontroller.tools.SteppedInputObject;

import java.io.Serializable;

/**
 * Базовый класс для реализации команд, исполняемых Microshell
 */
public abstract class BaseCommand extends SteppedInputObject implements IExecute, Serializable, Cloneable {

    private String name = "BaseCommand";
    private String description = "Base command";
    private MicroShell parentShell = null;

    public BaseCommand() {
        stepsCount = 0;
    }

    public String getName() {
        return name;
    }

    public abstract BaseCommand setArgs(String[] args) throws RuntimeException;


    public BaseCommand setName(String name) {
        this.name = name;
        return this;
    }


    public BaseCommand setDescription(String description) {
        this.description = description;
        return this;
    }

    public String getDescription() {
        return description;
    }

    public MicroShell getParentShell() {
        return parentShell;
    }

    public BaseCommand setParentShell(MicroShell parentShell) {
        this.parentShell = parentShell;
        return this;
    }

    @Override
    protected BaseCommand clone() throws CloneNotSupportedException {
        return (BaseCommand) super.clone();
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Команда очищающая коллекцию, делая ее пустой
 */
public class ClearCommand extends BaseCommand {
    public static final ClearCommand command = new ClearCommand();

    private ClearCommand() {
        this.setName("clear").setDescription(Phrases.getPhrase("ClearCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() throws RuntimeException {
        try {
            getParentShell().getParentTerminal().getCollectionController().getManagedCollection().clear();
        } catch (Exception e) {
            throw new RuntimeException(Phrases.getPhrase("Can'tExecuteCommand"));
        }
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.interfaces.IInputSource;
import ray1024.projects.collectioncontroller.interfaces.IOutputSource;
import ray1024.projects.collectioncontroller.interfaces.Tickable;
import ray1024.projects.collectioncontroller.tools.Phrases;

import java.io.IOException;

public class CommandBuilder implements Tickable {
    private BaseCommand command;
    private IInputSource reader;
    private IOutputSource writer;

    public CommandBuilder(IInputSource reader, IOutputSource writer) throws IOException {
        if (reader == null) throw new IOException(Phrases.getPhrase("InputSourceIsNull"));
        this.reader = reader;
        if (writer == null) throw new IOException(Phrases.getPhrase("OutputSourceIsNull"));
        this.writer = writer;
        writer.println(Phrases.getPhrase("TerminalWaitNewCommand"));
    }

    @Override
    public void tick() throws IOException {
        if (command == null) {
            try {
                if (!reader.hasNextLine()) return;
                command = CommandRegister.getRegisteredCommandByName(reader.nextLine());
                if (command == null) writer.println(Phrases.getPhrase("TerminalWaitNewCommand"));
                else if (!command.isObjectReady()) writer.println(command.getStepDescription());
            } catch (IllegalStateException illegalStateException) {
                writer.println(illegalStateException.getMessage());
            }
        } else if (!command.isObjectReady()) {
            try {
                if (!reader.hasNextLine()) return;
                command.inputLine(reader.nextLine());
                writer.println(command.getStepDescription());
            } catch (IllegalStateException illegalStateException) {
                writer.println(illegalStateException.getMessage());
            }
        } else writer.println(Phrases.getPhrase("TerminalWaitNewCommand"));
    }

    public BaseCommand getCommand() {
        return command == null || !command.isObjectReady() ? null : command;
    }

    public IInputSource getReader() {
        return reader;
    }

    public IOutputSource getWriter() {
        return writer;
    }

    public void reset() {
        command = null;
        writer.println(Phrases.getPhrase("TerminalWaitNewCommand"));
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.terminal.MicroShell;
import ray1024.projects.collectioncontroller.tools.Phrases;

import java.util.HashMap;
import java.util.stream.Stream;

/**
 * Класс-Инструмент
 * 1. Распознование команд и запрос аргументов в интерактивном режиме
 * 2. Создание коллекции команд из списка строк(для парсинга скриптов)
 */

public class CommandRegister {

    private static final HashMap<String, BaseCommand> commands = new HashMap<>();

    public static void registerCommand(BaseCommand command) {
        commands.put(command.getName(), command);
    }

    public static Stream<BaseCommand> getRegisteredCommandsStream() {
        return commands.values().stream();
    }


    public static BaseCommand getRegisteredCommandByName(String line) throws IllegalStateException {
        if ("".equals(line)) return null;
        String[] args = line.split(" ");
        if (!commands.containsKey(args[0])) throw new IllegalStateException(Phrases.getPhrase("WrongCommandInLine"));
        BaseCommand prototype = null;
        try {
            prototype = commands.get(args[0]).clone().setArgs(args);
        } catch (CloneNotSupportedException e) {
            System.out.println("COMMAND_BUILDER_COMMAND_CLONE_NOT_SUPPORTED_EXEPTION");
        }
        if(prototype != null)prototype.reset();
        return prototype;
    }

}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.terminal.MicroShell;
import ray1024.projects.collectioncontroller.tools.ConsoleSourceWriter;
import ray1024.projects.collectioncontroller.tools.FileSourceReader;
import ray1024.projects.collectioncontroller.tools.Phrases;

import java.io.IOException;

/**
 * Команда запускающая на исполнение скрипт
 * Максимальный размер скрипта: 102400 символов
 * Команды в скрипте указываются в том же порядке, что и в интерактивном режиме
 * При ошибке парсинга скрипта, он не будет выполнен, ни единой команды
 */
public class ExecuteScriptCommand extends BaseCommand {
    private String scriptFilename;
    public static final ExecuteScriptCommand command = new ExecuteScriptCommand();

    public ExecuteScriptCommand() {
        setName("execute_script").setDescription(Phrases.getPhrase("ExecuteScriptCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {
        try {
            getParentShell().getParentTerminal().addMicroshell(new MicroShell(getParentShell().getParentTerminal(), new CommandBuilder(new FileSourceReader(scriptFilename), new ConsoleSourceWriter()), false));
        } catch (IOException e) {
            throw new RuntimeException(Phrases.getPhrase("Can'tFindScript"));
        }
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args.length != 2) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        scriptFilename = args[1];
        return this;
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Завершает программу
 * Не сохраняет коллекцию в файл
 */
public class ExitCommand extends BaseCommand {
    public static final ExitCommand command = new ExitCommand();

    private ExitCommand() {
        setName("exit").setDescription(Phrases.getPhrase("ExitCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {
        System.exit(0);
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Выводит те элементы коллекции, которые имеют меньшее колличество студентов в группе чем задано в параметре
 */
public class FilterLessThanStudentsCountCommand extends BaseCommand {
    int studentsCount = 0;
    public static final FilterLessThanStudentsCountCommand command = new FilterLessThanStudentsCountCommand();

    private FilterLessThanStudentsCountCommand() {
        setName("filter_less_than_students_count").setDescription(Phrases.getPhrase("FilterLessThanStudentsCountCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {
        final int[] ind = new int[1];
        getParentShell().getParentTerminal().getCollectionController().getManagedCollection().stream()
                .filter((elem) -> elem.getStudentsCount() < studentsCount).forEach((elem) -> {
                    getParentShell().getParentTerminal().getWriter().println(String.format("\t%d. %s", ++ind[0], elem));
                });
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args != null && args.length == 2) {
            try {
                studentsCount = Integer.parseInt(args[1]);
                return this;
            } catch (NumberFormatException ignored) {
            }
        }
        throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Выводит те элементы коллекции, названия групп которых начинаются с аргумента команды
 */
public class FilterStartsWithNameCommand extends BaseCommand {
    String name = null;
    public static final FilterStartsWithNameCommand command = new FilterStartsWithNameCommand();

    private FilterStartsWithNameCommand() {
        setName("filter_starts_with_name").setDescription(Phrases.getPhrase("FilterStartsWithNameCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {
        final int[] ind = new int[1];
        getParentShell().getParentTerminal().getCollectionController().getManagedCollection().stream().filter((elem) -> elem.getName().startsWith(name)).forEach((elem) -> {
            getParentShell().getParentTerminal().getWriter().println(String.format("    %d. %s", ++ind[0], elem));
        });
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args != null && args.length == 2) {
            name = args[1];
            return this;
        }
        throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Выводит справку о доступных командах
 * {element} означает что в интерактивном режиме по каждому полю объекта вы будете опрошены
 * в скрипте все поля должны быть указаны начиная со следующей строки за командой, по 1 аргументу в строке
 */
public class HelpCommand extends BaseCommand {
    public static final HelpCommand command = new HelpCommand();

    private HelpCommand() {
        setName("help").setDescription(Phrases.getPhrase("HelpCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() throws RuntimeException {
        try {
            final int[] strNumber = {0};
            CommandRegister.getRegisteredCommandsStream().forEach((command) -> {
                getParentShell().getWriter().println(String.format("%d. %s: %s", ++strNumber[0], command.getName(), command.getDescription()));
            });
        } catch (Throwable throwable) {
            throw new RuntimeException(Phrases.getPhrase("Can'tExecuteCommand"));
        }
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Выводит служебную информация о коллекции
 * Например: дата создания, колличество элементов
 */
public class InfoCommand extends BaseCommand {
    public static final InfoCommand command = new InfoCommand();

    private InfoCommand() {
        this.setName("info").setDescription(Phrases.getPhrase("InfoCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() throws RuntimeException {
        try {
            getParentShell().getParentTerminal().getWriter().println(getParentShell().getParentTerminal().getCollectionController().getManagedCollection().getCollectionInfo().toString());
        } catch (Throwable ex) {
            throw new RuntimeException(Phrases.getPhrase("Can'tExecuteCommand"));
        }
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.data.MyCollection;
import ray1024.projects.collectioncontroller.data.StudyGroup;
import ray1024.projects.collectioncontroller.tools.Phrases;

import java.util.ArrayList;
import java.util.Comparator;

/**
 * Выводит элементы коллекции в порядке лексикографического не возростания названий их групп
 * Не меняет коллекцию
 */
public class PrintDescendingCommand extends BaseCommand {
    public static final PrintDescendingCommand command = new PrintDescendingCommand();

    private PrintDescendingCommand() {
        setName("print_descending").setDescription(Phrases.getPhrase("PrintDescendingDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {


        MyCollection<StudyGroup> coll = getParentShell().getParentTerminal().getCollectionController().getManagedCollection();
        ArrayList<Integer> arr = new ArrayList<>(coll.size());
        for (int i = 0; i < coll.size(); ++i) arr.add(i);

        arr.sort(Comparator.comparing(coll::get));
        for (int i = coll.size() - 1; i >= 0; --i) {
            getParentShell().getWriter().print("    " + (coll.size() - i) + ". ");
            getParentShell().getWriter().println(coll.get(arr.get(i)));
        }
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Удаляет из коллекции элемент с ID равным аргументом, если такой элемент в коллекции имеется
 */
public class RemoveByIDCommand extends BaseCommand {

    int removeID = -1;
    public static final RemoveByIDCommand command = new RemoveByIDCommand();

    private RemoveByIDCommand() {
        setName("remove_by_id").setDescription(Phrases.getPhrase("RemoveByIdCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {
        getParentShell().getParentTerminal().getCollectionController().getManagedCollection().getVec().removeIf((elem) -> {
            return elem.getId() == removeID;
        });
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args != null && args.length == 2) {
            try {
                removeID = Integer.parseInt(args[1]);
                return this;
            } catch (NumberFormatException ignored) {
            }
        }
        throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Удаляет из коллекции первый элемент
 */
public class RemoveFirstCommand extends BaseCommand {
    public static final RemoveFirstCommand command = new RemoveFirstCommand();

    private RemoveFirstCommand() {
        setName("remove_first").setDescription(Phrases.getPhrase("RemoveFirstCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {
        getParentShell().getParentTerminal().getCollectionController().getManagedCollection().getVec().remove(0);
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Сохраняет коллекцию в файл с названием указанным в переменной среды 'CCFilename'
 * Колекция хранится в формате XML
 */
public class SaveCommand extends BaseCommand {
    public static final SaveCommand command = new SaveCommand();

    private SaveCommand() {
        setName("save").setDescription(Phrases.getPhrase("SaveCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() throws RuntimeException {
        getParentShell().getParentTerminal().getCollectionController().saveCollection();
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Показывает все элементы коллекции
 */
public class ShowCommand extends BaseCommand {
    public static final ShowCommand command = new ShowCommand();

    private ShowCommand() {
        setName("show").setDescription(Phrases.getPhrase("ShowCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {
        getParentShell().getParentTerminal().getWriter().println(getParentShell().getParentTerminal().getCollectionController().getManagedCollection().toString());
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.tools.Phrases;

import java.util.Collections;

/**
 * Случайным образом перемешивает элементы коллекции
 */
public class ShuffleCommand extends BaseCommand {
    public static final ShuffleCommand command = new ShuffleCommand();

    private ShuffleCommand() {
        setName("shuffle").setDescription(Phrases.getPhrase("ShuffleCommandDescription"));
        CommandRegister.registerCommand(this);
    }

    @Override
    public void execute() {
        Collections.shuffle(getParentShell().getParentTerminal().getCollectionController().getManagedCollection().getVec());
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {

    }

    @Override
    public String getStepDescription() {
        return "";
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args == null || args.length != 1) throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
        return this;
    }
}
package ray1024.projects.collectioncontroller.commands;

import ray1024.projects.collectioncontroller.data.StudyGroup;
import ray1024.projects.collectioncontroller.tools.Phrases;

/**
 * Перезаписывает элемент коллекции с ID равным аргументу
 */
public class UpdateByIDCommand extends BaseCommand {
    int updateID = -1;
    StudyGroup elem = new StudyGroup();
    public static final UpdateByIDCommand command = new UpdateByIDCommand();

    private UpdateByIDCommand() {
        setName("update_by_id").setDescription(Phrases.getPhrase("UpdateByIdCommandDescription"));
        CommandRegister.registerCommand(this);
        stepsCount = elem.getStepsCount();
    }

    @Override
    public void execute() {

        elem.setId(getParentShell().getParentTerminal().getCollectionController().getManagedCollection().stream().filter((elem) -> {
            return elem.getId() == updateID;
        }).findFirst().get().getId());
        getParentShell().getParentTerminal().getCollectionController().getManagedCollection().getVec().replaceAll((i) -> {
            if (i.getId() == elem.getId()) return elem;
            return i;
        });
    }

    @Override
    public BaseCommand setArgs(String[] args) throws RuntimeException {
        if (args != null && args.length == 2) {
            try {
                updateID = Integer.parseInt(args[1]);
                return this;
            } catch (NumberFormatException ignored) {
            }
        }
        throw new RuntimeException(Phrases.getPhrase("WrongCommandArgs"));
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
        elem.inputLine(line);
    }

    @Override
    public String getStepDescription() {
        return elem.getStepDescription();
    }
}
package ray1024.projects.collectioncontroller.controllers;

import org.xml.sax.InputSource;
import ray1024.projects.collectioncontroller.data.MyCollection;
import ray1024.projects.collectioncontroller.data.StudyGroup;
import ray1024.projects.collectioncontroller.tools.Phrases;

import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Paths;

public class StudyGroupCollectionController {

    private String collectionFilename = "Collection.xml";
    private MyCollection<StudyGroup> managedCollection;

    public MyCollection<StudyGroup> getManagedCollection() {
        return managedCollection;
    }

    public StudyGroupCollectionController(String collectionFilename) {
        this.collectionFilename = collectionFilename;

    }

    public void loadCollectionFromFile() throws Exception {
        try {
            InputStreamReader inputStreamReader = new InputStreamReader(Files.newInputStream(Paths.get(collectionFilename)));
            XMLDecoder xmlDecoder = new XMLDecoder(new InputSource(inputStreamReader));
            managedCollection = (MyCollection<StudyGroup>) xmlDecoder.readObject();
            xmlDecoder.close();
            inputStreamReader.close();
            for (StudyGroup studyGroup : managedCollection.getVec())
                if (StudyGroup.getNextID() <= studyGroup.getId()) StudyGroup.setNextID(studyGroup.getId()+1);
        } catch (Throwable ex) {
            managedCollection = new MyCollection<>();
            throw new Exception(Phrases.getPhrase("CantLoadCollectionFromFile"));
        }
    }

    public void saveCollection() throws RuntimeException {
        if (collectionFilename == null) return;
        try {
            XMLEncoder xmlEncoder = new XMLEncoder(new BufferedOutputStream(new FileOutputStream(collectionFilename)));
            xmlEncoder.writeObject(managedCollection);
            xmlEncoder.close();
        } catch (FileNotFoundException e) {
            throw new RuntimeException(Phrases.getPhrase("CantSaveCollectionToFile"));
        }
    }

}
package ray1024.projects.collectioncontroller.controllers;

import ray1024.projects.collectioncontroller.interfaces.IUser;
import ray1024.projects.collectioncontroller.interfaces.IUserManager;
import ray1024.projects.collectioncontroller.interfaces.Tickable;

import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;
import java.util.stream.Stream;

public class UserManager implements IUserManager, Tickable {
    private final HashMap<String, IUser> users = new HashMap<>();
    private final Queue<IUser> unknowns = new LinkedList<>();

    public UserManager() {
    }

    @Override
    public boolean isRegistred(IUser user) {
        return user != null && users.get(user.getLogin()).getPasswordHash().equals(user.getPasswordHash());
    }

    @Override
    public IUserManager addUser(IUser user) {
        if (user == null) return this;
        if ((user.getLogin() == null || user.getPasswordHash() == null) && user.getConnection() != null)
            unknowns.add(user);
        else if (!users.containsKey(user.getLogin())) users.put(user.getLogin(), user);
        return this;
    }

    @Override
    public Stream<IUser> stream() {
        return users.values().stream();
    }

    @Override
    public void tick() throws IOException {

    }
}
package ray1024.projects.collectioncontroller.data;

import java.time.LocalDateTime;

/**
 * Вспомогательный класс используемый для хранения информации о коллекции
 */
public class CollectionInfo {
    public LocalDateTime initializationDateTime;
    public Class collectionElementType;
    public int elementsCount;

    public LocalDateTime getInitializationDateTime() {
        return initializationDateTime;
    }

    public void setInitializationDateTime(LocalDateTime initializationDateTime) {
        this.initializationDateTime = initializationDateTime;
    }

    public Class getCollectionElementType() {
        return collectionElementType;
    }

    public void setCollectionElementType(Class collectionElementType) {
        this.collectionElementType = collectionElementType;
    }

    public int getElementsCount() {
        return elementsCount;
    }

    public void setElementsCount(int elementsCount) {
        this.elementsCount = elementsCount;
    }


    @Override
    public String toString() {
        return String.format("CollectionInfo{\n   initializationDateTime : %s\n   collectionElementType : %s\n   elementsCount : %d\n}", initializationDateTime, collectionElementType, elementsCount);
    }
}
package ray1024.projects.collectioncontroller.data;

import ray1024.projects.collectioncontroller.tools.Phrases;
import ray1024.projects.collectioncontroller.tools.SteppedInputObject;

import java.util.Objects;

/**
 * Класс представляющий координаты в 2-мерном пространстве
 */
public class Coordinates extends SteppedInputObject {

    private float x; //Максимальное значение поля: 948
    private Integer y; //Значение поля должно быть больше -544, Поле не может быть null
    public static final Coordinates emptyCoordinates = new Coordinates();

    public Coordinates() {
        stepsCount = 2;
    }

    public float getX() {
        return x;
    }

    public Integer getY() {
        return y;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(Integer y) {
        this.y = y;
    }


    @Override
    public void inputLine(String line) throws IllegalStateException {
        try {
            switch (currentStep) {
                case 0:
                    x = Float.parseFloat(line);
                    if (x > 948) break;
                    ++currentStep;
                    return;
                case 1:
                    y = Integer.parseInt(line);
                    if (y < -543) break;
                    ++currentStep;
                    return;

            }
        } catch (NumberFormatException ignored) {
            throw new IllegalStateException(Phrases.getPhrase("CantParseNumber"));
        }
        throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
    }

    @Override
    public String getStepDescription() {
        switch (currentStep) {
            case 0:
                return Phrases.getPhrase("CoordinatesXDescription");
            case 1:
                return Phrases.getPhrase("CoordinatesYDescription");
            default:
                return Phrases.getPhrase("ReadySteppedInputObject");
        }
    }

    @Override
    public String toString() {
        return "Coordinates{" + "x=" + x + ", y=" + y + '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Coordinates that = (Coordinates) o;

        if (Float.compare(that.x, x) != 0) return false;
        return Objects.equals(y, that.y);
    }

    @Override
    public int hashCode() {
        int result = (x != +0.0f ? Float.floatToIntBits(x) : 0);
        result = 31 * result + (y != null ? y.hashCode() : 0);
        return result;
    }
}package ray1024.projects.collectioncontroller.data;


/**
 * Перечисление обозначающее варианты обучения для групп
 */
public enum FormOfEducation {

    DISTANCE_EDUCATION, FULL_TIME_EDUCATION, EVENING_CLASSES;
}package ray1024.projects.collectioncontroller.data;

import ray1024.projects.collectioncontroller.tools.Phrases;
import ray1024.projects.collectioncontroller.tools.SteppedInputObject;

/**
 * Класс представляющий координаты в 3х-мерном пространстве
 */
public class Location extends SteppedInputObject {
    private double x;
    private int y;
    private int z;
    public static final Location emptyLocation = new Location();

    public Location() {
        stepsCount = 3;
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
        try {
            switch (currentStep) {
                case 0:
                    x = Double.parseDouble(line);
                    ++currentStep;
                    return;
                case 1:
                    y = Integer.parseInt(line);
                    ++currentStep;
                    return;
                case 2:
                    z = Integer.parseInt(line);
                    ++currentStep;
                    return;
            }
        } catch (NumberFormatException ignored) {
            throw new IllegalStateException(Phrases.getPhrase("CantParseNumber"));
        }
        throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
    }

    @Override
    public String getStepDescription() {
        switch (currentStep) {
            case 0:
                return Phrases.getPhrase("LocationXDescription");
            case 1:
                return Phrases.getPhrase("LocationYDescription");
            case 2:
                return Phrases.getPhrase("LocationZDescription");
            default:
                return Phrases.getPhrase("ReadySteppedInputObject");
        }
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getZ() {
        return z;
    }

    public void setZ(int z) {
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Location location = (Location) o;

        if (Double.compare(location.x, x) != 0) return false;
        if (y != location.y) return false;
        return z == location.z;
    }

    @Override
    public int hashCode() {
        int result;
        long temp;
        temp = Double.doubleToLongBits(x);
        result = (int) (temp ^ (temp >>> 32));
        result = 31 * result + y;
        result = 31 * result + z;
        return result;
    }

    @Override
    public String toString() {
        return "Location{" + "x=" + x + ", y=" + y + ", z=" + z + '}';
    }
}
package ray1024.projects.collectioncontroller.data;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Vector;
import java.util.stream.Stream;

/**
 * Класс управляющий коллекцией учебных групп
 */
public class MyCollection<T> implements Serializable {
    private Vector<T> vec = new Vector<T>();
    private CollectionInfo collectionInfo = new CollectionInfo();

    public MyCollection() {
        collectionInfo.initializationDateTime = LocalDateTime.now();
        collectionInfo.collectionElementType = StudyGroup.class;
    }

    public Vector<T> getVec() {
        return vec;
    }

    public void setVec(Vector<T> vec) {
        this.vec = vec;
    }

    public void setCollectionInfo(CollectionInfo collectionInfo) {
        this.collectionInfo = collectionInfo;
    }

    public void clear() {
        vec.clear();
    }

    public CollectionInfo getCollectionInfo() {
        collectionInfo.elementsCount = vec.size();
        return collectionInfo;
    }

    public Stream<T> stream() {
        return vec.stream();
    }

    public String get(int index) {
        if (index < 0 || index >= vec.size()) return null;
        return (String) vec.get(index);
    }

    public int size() {
        return vec.size();
    }

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < vec.size(); ++i) {
            stringBuilder.append("\n    ").append(i + 1).append(". ").append(vec.get(i).toString());
        }
        return stringBuilder.toString();
    }
}
package ray1024.projects.collectioncontroller.data;

import ray1024.projects.collectioncontroller.tools.Phrases;
import ray1024.projects.collectioncontroller.tools.SteppedInputObject;

import java.util.Objects;

/**
 * Класс представляющий человека
 */
public class Person extends SteppedInputObject {
    private String name = ""; //Поле не может быть null, Строка не может быть пустой
    private double weight = -1.0; //Значение поля должно быть больше 0
    private Location location = Location.emptyLocation; //Поле может быть null
    public static final Person emptyPerson = new Person();

    public Person() {
        stepsCount = 2 + Location.emptyLocation.getStepsCount();
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
        try {
            switch (currentStep) {
                case 0:
                    if (line == null) break;
                    name = line;
                    ++currentStep;
                    return;
                case 1:
                    weight = Double.parseDouble(line);
                    if (weight <= 0.0d) break;
                    ++currentStep;
                    return;
                default:
                    if (Location.emptyLocation == location) {
                        if ("yes".equals(line)) {
                            location = new Location();
                            return;
                        } else if ("no".equals(line)) {
                            location = null;
                            stepsCount = 2;
                            return;
                        } else throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
                    }
                    if (location == null || location.isObjectReady()) return;
                    location.inputLine(line);
                    ++currentStep;
                    return;
            }
        } catch (NumberFormatException numberFormatException) {
            throw new IllegalStateException(Phrases.getPhrase("CantParseNumber"));
        }
        throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
    }

    @Override
    public String getStepDescription() {
        switch (currentStep) {
            case 0:
                return Phrases.getPhrase("PersonNameDescription");
            case 1:
                return Phrases.getPhrase("PersonWeightDescription");
            default:
                if (Location.emptyLocation == location) return Phrases.getPhrase("PersonLocationIsNullDescription");
                if (!isObjectReady()) return location.getStepDescription();
                return Phrases.getPhrase("ReadySteppedInputObject");
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getWeight() {
        return weight;
    }

    public void setWeight(double weight) {
        this.weight = weight;
    }

    public Location getLocation() {
        return location;
    }

    public void setLocation(Location location) {
        this.location = location;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;

        if (Double.compare(person.weight, weight) != 0) return false;
        if (!Objects.equals(name, person.name)) return false;
        return Objects.equals(location, person.location);
    }

    @Override
    public int hashCode() {
        int result;
        long temp;
        result = name != null ? name.hashCode() : 0;
        temp = Double.doubleToLongBits(weight);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        result = 31 * result + (location != null ? location.hashCode() : 0);
        return result;
    }

    @Override
    public String toString() {
        return "Person{" + "name='" + name + '\'' + ", weight=" + weight + ", location=" + location + '}';
    }
}
package ray1024.projects.collectioncontroller.data;

import ray1024.projects.collectioncontroller.commands.BaseCommand;
import ray1024.projects.collectioncontroller.interfaces.IRequest;
import ray1024.projects.collectioncontroller.interfaces.IUser;
import ray1024.projects.collectioncontroller.tools.RequestType;

import java.io.Serializable;

public class Request implements Serializable, IRequest {
    private RequestType requestType;
    private BaseCommand command;
    private IUser user;

    public Request() {
    }

    @Override
    public RequestType getRequestType() {
        return requestType;
    }

    @Override
    public IRequest setRequestType(RequestType requestType) {
        this.requestType = requestType;
        return this;
    }

    @Override
    public BaseCommand getCommand() {
        return command;
    }

    @Override
    public IRequest setCommand(BaseCommand command) {
        this.command = command;
        return this;
    }

    @Override
    public IUser getUser() {
        return user;
    }

    @Override
    public IRequest setUser(IUser user) {
        this.user = user;
        return this;
    }
}
package ray1024.projects.collectioncontroller.data;

import ray1024.projects.collectioncontroller.tools.ResponseType;

import java.io.Serializable;

public class Response implements Serializable {
    private ResponseType responseType;
    private String answer;

    public Response() {
    }

    public ResponseType getResponseType() {
        return responseType;
    }

    public Response setResponseType(ResponseType responseType) {
        this.responseType = responseType;
        return this;
    }

    public String getAnswer() {
        return answer;
    }

    public Response setAnswer(String answer) {
        this.answer = answer;
        return this;
    }
}
package ray1024.projects.collectioncontroller.data;

/**
 * Перечисление используемое для указания семестра обучения для группы
 */
public enum Semester {
    FIRST,
    FOURTH,
    FIFTH,
    SIXTH,
    EIGHTH;
}package ray1024.projects.collectioncontroller.data;

import ray1024.projects.collectioncontroller.tools.Phrases;
import ray1024.projects.collectioncontroller.tools.SteppedInputObject;

import java.time.LocalDateTime;

/**
 * Класс представляющий учебную группу
 * Элементы коллекции являются представителями данного класса
 * Сортировка по-умолчанию : по лексикографическому неубыванию названий групп
 */
public class StudyGroup extends SteppedInputObject implements Comparable<StudyGroup> {
    private static int NextID = 1;

    private int id; //Значение поля должно быть больше 0, Значение этого поля должно быть уникальным, Значение этого поля должно генерироваться автоматически
    private String name; //Поле не может быть null, Строка не может быть пустой
    private Coordinates coordinates; //Поле не может быть null
    private java.time.LocalDateTime creationDate; //Поле не может быть null, Значение этого поля должно генерироваться автоматически
    private int studentsCount; //Значение поля должно быть больше 0
    private FormOfEducation formOfEducation; //Поле может быть null
    private Semester semesterEnum; //Поле не может быть null
    private Person groupAdmin; //Поле может быть null


    public StudyGroup() {
        id = (NextID++);
        creationDate = LocalDateTime.now();
        name = "EmptyName";
        coordinates = Coordinates.emptyCoordinates;
        studentsCount = 0;
        formOfEducation = null;
        groupAdmin = Person.emptyPerson;
        stepsCount = 6 + Coordinates.emptyCoordinates.getStepsCount() + Person.emptyPerson.getStepsCount();
    }

    @Override
    public void inputLine(String line) throws IllegalStateException {
        try {
            if (currentStep == 0) {
                name = line;
                if (name == null || "".equals(name))
                    throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
                ++currentStep;
            } else if (currentStep >= 1 && currentStep <= Coordinates.emptyCoordinates.getStepsCount()) {
                coordinates.inputLine(line);
                ++currentStep;
            } else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 1) {
                studentsCount = Integer.parseInt(line);
                if (studentsCount < 1) throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
                ++currentStep;
            } else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 2) {
                if ("yes".equals(line)) ++currentStep;
                else if ("no".equals(line)) {
                    formOfEducation = null;
                    currentStep += 2;
                } else throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
            } else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 3) {
                formOfEducation = FormOfEducation.valueOf(line);
                ++currentStep;
            } else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 4) {
                semesterEnum = Semester.valueOf(line);
                ++currentStep;
            } else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 5) {
                if ("yes".equals(line)) {
                    groupAdmin = new Person();
                    ++currentStep;
                } else if ("no".equals(line)) {
                    groupAdmin = null;
                    currentStep += 1 + Person.emptyPerson.getStepsCount();
                } else throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
            } else if (currentStep >= Coordinates.emptyCoordinates.getStepsCount() + 6 && currentStep < Coordinates.emptyCoordinates.getStepsCount() + 6 + Person.emptyPerson.getStepsCount()) {
                groupAdmin.inputLine(line);
                ++currentStep;
            }
        } catch (NumberFormatException numberFormatException) {
            throw new IllegalStateException(Phrases.getPhrase("CantParseNumber"));
        } catch (IllegalArgumentException illegalArgumentException) {
            throw new IllegalStateException(Phrases.getPhrase("WrongArgument"));
        }
    }

    @Override
    public String getStepDescription() {
        if (currentStep == 0) return Phrases.getPhrase("StudyGroupNameDescription");
        else if (currentStep >= 1 && currentStep <= Coordinates.emptyCoordinates.getStepsCount())
            return Phrases.getPhrase("StudyGroupCoordinatesDescription") + "\n" + coordinates.getStepDescription();
        else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 1)
            return Phrases.getPhrase("StudyGroupStudentsCountDescription");
        else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 2)
            return Phrases.getPhrase("StudyGroupFormOfEducationIsNullDescription");
        else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 3)
            return Phrases.getPhrase("StudyGroupFormOfEducationDescription");
        else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 4)
            return Phrases.getPhrase("StudyGroupSemesterDescription");
        else if (currentStep == Coordinates.emptyCoordinates.getStepsCount() + 5)
            return Phrases.getPhrase("StudyGroupGroupAdminIsNullDescription");
        else if (currentStep >= Coordinates.emptyCoordinates.getStepsCount() + 6 && currentStep < Coordinates.emptyCoordinates.getStepsCount() + 6 + Person.emptyPerson.getStepsCount())
            return Phrases.getPhrase("StudyGroupGroupAdminDescription") + "\n" + groupAdmin.getStepDescription();
        else return Phrases.getPhrase("ReadySteppedInputObject");
    }

    @Override
    public int compareTo(StudyGroup o) {
        if (this.equals(o)) return 0;
        return this.name.compareTo(o.name);
    }

    public static int getNextID() {
        return NextID;
    }

    public static void setNextID(int nextID) {
        NextID = nextID;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        this.creationDate = creationDate;
    }

    public void setStudentsCount(int studentsCount) {
        this.studentsCount = studentsCount;
    }

    public FormOfEducation getFormOfEducation() {
        return formOfEducation;
    }

    public void setFormOfEducation(FormOfEducation formOfEducation) {
        this.formOfEducation = formOfEducation;
    }

    public Semester getSemesterEnum() {
        return semesterEnum;
    }

    public void setSemesterEnum(Semester semesterEnum) {
        this.semesterEnum = semesterEnum;
    }

    public Person getGroupAdmin() {
        return groupAdmin;
    }

    public void setGroupAdmin(Person groupAdmin) {
        this.groupAdmin = groupAdmin;
    }

    public String getName() {
        return name;
    }

    public int getStudentsCount() {
        return studentsCount;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "StudyGroup{" + "id=" + id + ", name='" + name + '\'' + ", coordinates=" + coordinates + ", creationDate=" + creationDate + ", studentsCount=" + studentsCount + ", formOfEducation=" + formOfEducation + ", semesterEnum=" + semesterEnum + ", groupAdmin=" + groupAdmin + '}';
    }

    @Override
    public int hashCode() {
        return super.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null || obj.getClass() != getClass()) return false;
        StudyGroup gr = (StudyGroup) obj;
        return name.equals(gr.name) && coordinates.equals(gr.coordinates) && studentsCount == gr.studentsCount && formOfEducation.equals(gr.formOfEducation) && semesterEnum.equals(gr.semesterEnum) && groupAdmin.equals(gr.groupAdmin);
    }
}package ray1024.projects.collectioncontroller.data;

import ray1024.projects.collectioncontroller.interfaces.IUser;
import ray1024.projects.collectioncontroller.interfaces.Tickable;
import ray1024.projects.collectioncontroller.terminal.Terminal;

import java.io.IOException;
import java.io.Serializable;
import java.net.Socket;

public class User implements Serializable, IUser, Tickable {
    private String login;
    private String passwordHash;
    private Socket connection;
    private Terminal terminal;

    @Override
    public Socket getConnection() {
        return connection;
    }

    @Override
    public User setConnection(Socket connection) {
        this.connection = connection;
        return this;
    }

    @Override
    public String getLogin() {
        return login;
    }

    @Override
    public User setLogin(String login) {
        this.login = login;
        return this;
    }

    @Override
    public String getPasswordHash() {
        return passwordHash;
    }

    @Override
    public User setPasswordHash(String passwordHash) {
        this.passwordHash = passwordHash;
        return this;
    }

    @Override
    public Terminal getTerminal() {
        return terminal;
    }

    @Override
    public IUser setTerminal(Terminal terminal) {
        this.terminal = terminal;
        return this;
    }

    @Override
    public void tick() throws IOException {

    }
}
package ray1024.projects.collectioncontroller.interfaces;

/**
 * Интерфейс используемый всеми исполняемыми командами для выполнения кода команд
 */
public interface IExecute {
    void execute() throws RuntimeException;
}
package ray1024.projects.collectioncontroller.interfaces;

import java.io.IOException;

public interface IInputSource {
    String nextLine() throws IOException;
    boolean hasNextLine() throws IOException;
}
package ray1024.projects.collectioncontroller.interfaces;

public interface IOutputSource {
    void println(String line);
    void print(String line);
}
package ray1024.projects.collectioncontroller.interfaces;

import ray1024.projects.collectioncontroller.commands.BaseCommand;
import ray1024.projects.collectioncontroller.tools.RequestType;

public interface IRequest {
    public RequestType getRequestType();

    public IRequest setRequestType(RequestType requestType);

    public BaseCommand getCommand();

    public IRequest setCommand(BaseCommand command);

    public IUser getUser();

    public IRequest setUser(IUser user);
}
package ray1024.projects.collectioncontroller.interfaces;

public interface ISteppedInput {
    void inputLine(String line) throws IllegalStateException;

    boolean isObjectReady();

    String getStepDescription();

    void reset();


}
package ray1024.projects.collectioncontroller.interfaces;

import ray1024.projects.collectioncontroller.data.User;
import ray1024.projects.collectioncontroller.terminal.Terminal;

import java.net.Socket;

public interface IUser {
    Socket getConnection();

    User setConnection(Socket connection);

    String getLogin();

    IUser setLogin(String login);

    String getPasswordHash();

    IUser setPasswordHash(String passwordHash);

    Terminal getTerminal();

    IUser setTerminal(Terminal terminal);
}
package ray1024.projects.collectioncontroller.interfaces;

import java.util.stream.Stream;

public interface IUserManager {
    boolean isRegistred(IUser user);

    IUserManager addUser(IUser user);

    Stream<IUser> stream();
}
package ray1024.projects.collectioncontroller.interfaces;

import java.io.IOException;

public interface Tickable {
    void tick() throws IOException;
}
package ray1024.projects.collectioncontroller.server;

import ray1024.projects.collectioncontroller.tools.Phrases;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class ConnectionAcceptor {
    private final ServerSocket serverSocket;

    public ConnectionAcceptor() {
        try {
            serverSocket = new ServerSocket();
            serverSocket.bind(new InetSocketAddress("localhost", 44147));
            serverSocket.setSoTimeout(1);
        } catch (IOException e) {
            throw new RuntimeException(Phrases.getPhrase("ServerCan'tStart"));
        }
    }

    public Socket getNewConnection() {
        try {
            return serverSocket.accept();
        } catch (IOException e) {
            return null;
        }
    }
}
package ray1024.projects.collectioncontroller.server;

import ray1024.projects.collectioncontroller.controllers.StudyGroupCollectionController;
import ray1024.projects.collectioncontroller.controllers.UserManager;
import ray1024.projects.collectioncontroller.data.User;
import ray1024.projects.collectioncontroller.interfaces.IUserManager;
import ray1024.projects.collectioncontroller.interfaces.Tickable;
import ray1024.projects.collectioncontroller.terminal.Terminal;
import ray1024.projects.collectioncontroller.tools.ConsoleSourceWriter;
import ray1024.projects.collectioncontroller.tools.NonBlockingConsoleSourceReader;

import java.io.IOException;
import java.net.Socket;

public class Server implements Tickable {
    private ConnectionAcceptor connectionAcceptor;
    private IUserManager usersManager;
    private Terminal serverTerminal;

    public Server() {
        connectionAcceptor = new ConnectionAcceptor();
        usersManager = new UserManager();

        try {
            serverTerminal = new Terminal(new NonBlockingConsoleSourceReader(), new ConsoleSourceWriter());
            serverTerminal.setCollectionController(new StudyGroupCollectionController(System.getenv("CCFilename")));
            serverTerminal.getCollectionController().loadCollectionFromFile();
        } catch (Exception e) {
            serverTerminal.getWriter().println(e.getMessage());
        }
    }

    @Override
    public void tick() throws IOException {
        Socket currConnect = connectionAcceptor.getNewConnection();
        usersManager.addUser(new User().setConnection(currConnect));
        serverTerminal.tick();
    }
}
package ray1024.projects.collectioncontroller.terminal;

import ray1024.projects.collectioncontroller.commands.BaseCommand;
import ray1024.projects.collectioncontroller.commands.CommandBuilder;
import ray1024.projects.collectioncontroller.commands.CommandRegister;
import ray1024.projects.collectioncontroller.interfaces.IInputSource;
import ray1024.projects.collectioncontroller.interfaces.IOutputSource;
import ray1024.projects.collectioncontroller.interfaces.Tickable;
import ray1024.projects.collectioncontroller.tools.Phrases;

import java.io.IOException;

/**
 * Класс предназначенный для исполнения команд из очереди, пока та не закончится
 */
public class MicroShell implements Tickable {
    private final Terminal parentTerminal;
    private CommandBuilder commandBuilder;
    private boolean isInteractive;
    private boolean isDone = false;

    public MicroShell(Terminal parentTerminal, CommandBuilder _commandBuilder, boolean IsInteractive) {
        this.parentTerminal = parentTerminal;
        if (_commandBuilder == null) throw new RuntimeException(Phrases.getPhrase(""));
        commandBuilder = _commandBuilder;
        isInteractive = IsInteractive;
    }

    @Override
    public void tick() {
        if (isDone) return;
        try {
            commandBuilder.tick();
        } catch (IOException e) {
            isDone = true;
        }
        if (commandBuilder.getCommand() != null) {
            commandBuilder.getCommand().setParentShell(this).execute();
            commandBuilder.reset();
        }
    }

    public IInputSource getReader() {
        return commandBuilder.getReader();
    }

    public IOutputSource getWriter() {
        return commandBuilder.getWriter();
    }

    public Terminal getParentTerminal() {
        return parentTerminal;
    }

    public boolean isDone() {
        return isDone;
    }
}
package ray1024.projects.collectioncontroller.terminal;

import ray1024.projects.collectioncontroller.commands.CommandBuilder;
import ray1024.projects.collectioncontroller.controllers.StudyGroupCollectionController;
import ray1024.projects.collectioncontroller.interfaces.IInputSource;
import ray1024.projects.collectioncontroller.interfaces.IOutputSource;
import ray1024.projects.collectioncontroller.interfaces.Tickable;
import ray1024.projects.collectioncontroller.tools.Phrases;

import java.io.IOException;
import java.util.ArrayList;

/**
 * Класс хранящий коллекцию и управляющий дочерними MicroShell'ами
 * Так же занимается загрузкой и сохранением коллекции
 * Максимальное колличество исполняющихся Microshell'ов : 10
 */
public class Terminal implements Tickable {
    private static final int microShellsLimit = 10;
    private static final int MainShell = 0;
    private ArrayList<MicroShell> microShells;
    private StudyGroupCollectionController collectionController;

    private IInputSource reader;
    private IOutputSource writer;


    public IOutputSource getWriter() {
        return writer;
    }

    public Terminal(IInputSource inputter, IOutputSource outputter) throws IllegalArgumentException {
        microShells = new ArrayList<>(microShellsLimit);
        reader = inputter;
        writer = outputter;
        try {
            microShells.add(new MicroShell(this, new CommandBuilder(reader, writer), true));
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage());
        }
    }


    public StudyGroupCollectionController getCollectionController() {
        return collectionController;
    }

    public void setCollectionController(StudyGroupCollectionController collectionController) {
        this.collectionController = collectionController;
    }

    public void addMicroshell(MicroShell microShell) {
        if (microShells.size() == microShellsLimit)
            throw new IllegalStateException(Phrases.getPhrase("TooManyMicroshells"));
        microShells.add(microShell);
    }

    @Override
    public void tick() throws IOException {
        while (microShells.get(microShells.size() - 1).isDone()) microShells.remove(microShells.size() - 1);
        microShells.get(microShells.size() - 1).tick();
    }
}
package ray1024.projects.collectioncontroller.tools;

import ray1024.projects.collectioncontroller.interfaces.IInputSource;

import java.io.IOException;
import java.util.Scanner;

public class ConsoleSourceReader implements IInputSource {
    private Scanner scanner = new Scanner(System.in);

    @Override
    public String nextLine() throws IOException {
        return scanner.nextLine();
    }

    @Override
    public boolean hasNextLine() throws IOException {
        return scanner.hasNextLine();
    }
}
package ray1024.projects.collectioncontroller.tools;

import ray1024.projects.collectioncontroller.interfaces.IOutputSource;

public final class ConsoleSourceWriter implements IOutputSource {
    @Override
    public void println(String line) {
        System.out.println(line);
    }

    @Override
    public void print(String line) {
        System.out.print(line);
    }
}
package ray1024.projects.collectioncontroller.tools;

import ray1024.projects.collectioncontroller.interfaces.IInputSource;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Scanner;

public final class FileSourceReader implements IInputSource {
    private Scanner scanner;

    public FileSourceReader(String filename) throws IOException {
        scanner = new Scanner(Files.newInputStream(Paths.get(filename)));
    }

    @Override
    public String nextLine() {
        return scanner.nextLine();
    }

    @Override
    public boolean hasNextLine() {
        return scanner.hasNextLine();
    }
}
package ray1024.projects.collectioncontroller.tools;

import ray1024.projects.collectioncontroller.interfaces.IInputSource;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;

public final class NonBlockingConsoleSourceReader implements IInputSource {

    private static final int BUFFER_SIZE = 128;
    private final Reader reader = new InputStreamReader(System.in);

    private final StringBuilder stringBuilder = new StringBuilder();
    private String line;
    private final char[] buffer = new char[BUFFER_SIZE];
    private int enterIndex = -1, right = 0;


    @Override
    public String nextLine() {
        if (enterIndex == -1) return "";
        line = stringBuilder.substring(0, enterIndex);
        stringBuilder.delete(0, enterIndex + 1);
        right = 0;
        enterIndex = -1;
        return line;
    }

    @Override
    public boolean hasNextLine() throws IOException {
        while (reader.ready()) {
            int cnt = reader.read(buffer);
            stringBuilder.append(buffer, 0, cnt);
        }
        if (enterIndex == -1) {
            for (enterIndex = right; enterIndex < stringBuilder.length(); ++enterIndex) {
                if (stringBuilder.charAt(enterIndex) == '\n') return true;
            }
            enterIndex = -1;
            return false;
        } else {
            return true;
        }
    }
}
package ray1024.projects.collectioncontroller.tools;

import ray1024.projects.collectioncontroller.data.FormOfEducation;
import ray1024.projects.collectioncontroller.data.Semester;

import java.util.Arrays;
import java.util.HashMap;

/**
 * Класс-Инструмент
 * Содержит все фразы выводимые на обозрение пользователя
 * В будущем с помощью функции setLocale можно будет менять язык используемый в приложении
 */
public class Phrases {

    private static final HashMap<String, String> phrases = new HashMap<>();

    static {
        setLocale("Russian");
    }

    private Phrases() {
    }

    public static String getPhrase(String phraseName) {
        return phrases.get(phraseName);
    }

    public static void setLocale(String locale) {
        if (locale.equals("Russian")) {
            phrases.clear();
            phrases.put("ReadySteppedInputObject", "Объект готов.");
            phrases.put("WrongArgument", "Введеное вами значение не соответствует обозначенным условиям.");
            phrases.put("CantParseNumber", "Распознование числа не удалось, возможно вы ввели не число.");
            phrases.put("CoordinatesXDescription", "Пожалуйста введите значение координаты X(вещественное число) не превосходящее 948:");
            phrases.put("CoordinatesYDescription", "Пожалуйста введите значение координаты Y(целое число) не меньшее -543:");
            phrases.put("LocationXDescription", "Пожалуйста введите значение координаты X(вещественное число):");
            phrases.put("LocationYDescription", "Пожалуйста введите значение координаты Y(целое число):");
            phrases.put("LocationZDescription", "Пожалуйста введите значение координаты Z(целое число):");
            phrases.put("PersonNameDescription", "Пожалуйста введите имя человека:");
            phrases.put("PersonWeightDescription", "Пожалуйста введите ширину персоны(вещественное, положительное число):");
            phrases.put("PersonLocationIsNullDescription", "Желаете ли вы указать местоположение человека?(yes/no)");
            phrases.put("StudyGroupNameDescription", "Пожалуйста введите название учебной группы(оно не может быть пустым):");
            phrases.put("StudyGroupCoordinatesDescription", "Пожалуйста введите координаты местоположения группы:");
            phrases.put("StudyGroupStudentsCountDescription", "Пожалуйста введите колличество студентов в группе(положительное число):");
            phrases.put("StudyGroupFormOfEducationIsNullDescription", "Желаете ли вы указать форму обучения группы?(yes/no)");
            phrases.put("StudyGroupFormOfEducationDescription", "Пожалуйста выберите и введите название формы обучения из списка:\n" + Arrays.toString(FormOfEducation.values()));
            phrases.put("StudyGroupSemesterDescription", "Пожалуйста выберите и введите название семестра из списка:\n" + Arrays.toString(Semester.values()));
            phrases.put("StudyGroupGroupAdminIsNullDescription", "Желаете ли вы указать администратора группы?(yes/no)");
            phrases.put("StudyGroupGroupAdminDescription", "Пожалуйста введите данные администратора группы:");
            phrases.put("CantLoadCollectionFromFile", "При загрузке коллекции из файла произошла ошибка.");
            phrases.put("CollectionFileDoesn'tExist", "Файл содержащий коллекцию не существует либо недоступен.");
            phrases.put("CantSaveCollectionToFile", "При сохранении коллекции произошла ошибка. Возможно файл недоступен для сохранения или занят.");
            phrases.put("CantCreateMicroshell", "Для текущего терминала создано слишком много исполнителей создание еще одного невозможно.");
            phrases.put("InputterCan'tBeNullException", "Источник данных для терминала не может быть null.");
            phrases.put("OutputterCan'tBeNullException", "Приемник данных из терминала не может быть null.");
            phrases.put("TerminalWaitNewCommand", "Пожалуйста введите команду(для получения справки по доступным командам используется команда help):");
            phrases.put("WrongCommandInLine", "Введена неверная команда.");
            phrases.put("WrongCommandSyntax", "Неверный синтаксис команды.");
            phrases.put("HelpCommandDescription", "Выводит список доступных команд.");
            phrases.put("Can'tExecuteCommand", "Невозможно выполнить команду.");
            phrases.put("InfoCommandDescription", "Выводит основную информацию о коллекции.");
            phrases.put("AddCommandDescription", "Добавляет новый элемент в коллекцию.");
            phrases.put("ClearCommandDescription", "Очищает коллекцию.");
            phrases.put("EnvironmentVariableDoesn'tExist", "Переменная среды 'CCFilename' не задана.");
            phrases.put("AddIfMinCommandDescription", "Добавляет новый элемент в коллекцию, если он меньше любого элемента коллекции/");
            phrases.put("ExitCommandDescription", "Завершает программу без сохранения коллекции.");
            phrases.put("ShowCommandDescription", "Показывает коллекцию.");
            phrases.put("SaveCommandDescription", "Сохраняет коллекцию в файл.");
            phrases.put("RemoveFirstCommandDescription", "Удаляет первый элемент коллекции.");
            phrases.put("ShuffleCommandDescription", "Случайным образом меняет местами элементы коллекции.");
            phrases.put("PrintDescendingDescription", "Выводит коллекцию в лексикографическом порядке не меняя ее.");
            phrases.put("WrongCommandArgs", "Введенные вами аргументы команды неверны.");
            phrases.put("RemoveByIdCommandDescription", "Удаляет элемент коллекции с тем же ID что и аргумент команды.");
            phrases.put("UpdateByIdCommandDescription", "Заменяет элемент с указанным ID на новый.");
            phrases.put("FilterLessThanStudentsCountCommandDescription", "Показывает учебные группы в которых студентов меньше указано в аргументе команды.");
            phrases.put("FilterStartsWithNameCommandDescription", "Показывает группы названия которых начинаются с аргумента команды.");
            phrases.put("TooManyMicroshells", "В текущем терминале слишком много исполнителей создание еще одного невозможно.");
            phrases.put("ExecuteScriptCommandDescription", "Выполняет скрипт с названием указанным в аргументе.");
            phrases.put("Can'tFindScript", "Не удалось найти скрипт.");
            phrases.put("InputSourceIsNull", "Источник входных данных не может быть null");
            phrases.put("OutputSourceIsNull", "Источник выходных данных не может быть null");
            phrases.put("ServerCan'tStart", "При старте сервера произошла ошибка");
        }
    }
}
package ray1024.projects.collectioncontroller.tools;

public enum RequestType {
    REGISTRATION, EXECUTION_COMMAND, DISCONNECTION
}
package ray1024.projects.collectioncontroller.tools;

public enum ResponseType {
    SUCCESS, FAILURE
}
package ray1024.projects.collectioncontroller.tools;

import ray1024.projects.collectioncontroller.interfaces.ISteppedInput;

public abstract class SteppedInputObject implements ISteppedInput {
    protected int currentStep = 0;
    protected int stepsCount = 0;

    @Override
    public void reset() {
        currentStep = 0;
    }

    public int getStepsCount() {
        return stepsCount;
    }

    @Override
    public boolean isObjectReady() {
        return currentStep >= stepsCount;
    }
}
